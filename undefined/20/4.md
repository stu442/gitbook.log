# 4장 실용주의 편집증

> 여러분은 완벽한 소프트웨어를 만들 수 없다.

아무도 믿지 말아라. 심지어 자기 자신도. 완벽한 코드는 만들 수 없다.\
실용주의 프로그래머는 실수에 대비한 방어책을 마련한다.

### 23. 계약에 의한 설계

정직한 거래를 보장하는 최선의 해법 중 하나는 "계약"이다.\
소프트웨어 모듈이 서로 소통하는 것을 돕기 위해 "계약"을 사용할 수 있다.

'계약에 의한 설계'(Design By Contract, DBC) 이다.\
이는 프로그램의 정확성을 보장하기 위한 기법이다.\
정확한 프로그램이란, 자신이 하는 일이라고 주장하는 것보다 많지도, 적지도 않게 딱 그 만큼만 하는 프로그램이다.

함수와 메서드는 뭔가를 한다.\
뭔가를 하기 전, 전제 조건이 있을 것이고,\
뭔가가 끝난 후 상태가 어떨 것이라고 선언할 수 있다.

전제와 선언을 다음과 같이 설명한다.

1. 선행 조건 (precondition)
   1. 루틴이 호출되기 위해 참이어야 하는 것. 즉, 루틴의 요구사항
2. 후행 조건(postcondition)
   1. 루틴이 자기가 할 것이라고 보장하는 것. 즉, 루틴이 완료되었을 때 세상의 상태
3. 클래스 불변식 (class invariant)
   1. 호출자 입장에서 볼 때 이 조건이 언제나 참인 것을 클래스가 보장한다.
   2. (상태는 불변해야한다.)

> 만약 호출자가 루틴의 모든 선행 조건을 충족한다면, 해당 루틴은 종료 시 모든 후행 조건과 불변식이 참이 되는 것을 보장한다.

만약 계약 당사자 중 어느 한쪽이라도 이 계약을 지키지 못하면, 해결방안이 실행된다.

> 계약으로 설계하라

시작하기 전에 자신이 수용할 것은 엄격하게 확인하고,\
내어 줄 것에 대해서는 최소한도를 약속하라.

DBC는 설계 기법이다.\
자동 검사가 없더라도, 계약을 코드 주석이나 단위테스트로 넣을 수 있다.\
assert도 좋은 방법이다.

### 24. 죽은 프로그램은 거짓말을 하지 않는다.

'그런 일은 절대 일어날 리 없어'라는 함정에 빠지기 쉽다.

**만약 에러가 발생했다면, 일찍 작동을 멈춰라.**\
일반적으로 죽은 프로그램이 끼치는 피해는 이상한 상태의 프로그램이 끼치는 피해보다 훨씬 적은 법이다.

### 25. 단정적 프로그래밍

'그런 일은 절대 일어날 리 없어'\
자신을 기만하는 행위이다.

이럴 땐 _단정문(assert)으로 불가능한 상황을 예방하자._

'하지만 물론 그런 일은 절대 일어나지 않을 거야'라는 생각이 든다면, 그런일을 확인하는 코드를 추가하자.\
프로덕션 레벨에서는 assert는 없어진다.

하지만, 진짜 오류 처리를 해야하는 곳에 단정을 대신 사용하지 말라.\
결코 일어나면 안 되는 것들을 검사하라.

성능 문제가 있더라도, 문제가 있는 부분의 assert문만 지우고\
남겨둬라.

일반적으로 로직 7줄 당 1개의 assert문이 있어야 한다고 한다.\
(출처 : https://www.youtube.com/watch?v=6ts1Uxp\_i3w\&t=516s)

### 26. 리소스 사용의 균형

우리는 코딩할 때 언제나 리소스를 관리한다.\
메모리, 트랜잭션, 스레드, 네트워크 연결, 파일, 타이머 등...

_자신이 시작한 것은 자신이 끝내라._

리소스를 할당하는 함수나 객체가 리소스를 해체하는 책임 역시 져야한다.

잘 모르겠을 땐 언제나 스코프를 줄이는 편이 낫다._지역적으로 행동하라._

### 27. 헤드라이트를 앞서가지 말라.

> 예측은 힘들다. 특히 미래에 대해서는
>
> * 요기 베라

소프트웨어 개발에서도 너무 먼 미래는 내다볼 수 없다._작은 단계들을 밟아라. 언제나._

우리는 미래 유지 보수를 고려해 설계해야한다._하지만 우리가 볼 수 있는 미래까지만 고려해야한다._

미래가 어떤 모습일지 더 많이 예측하려 할수록 틀릴 가능성이 높아진다.
